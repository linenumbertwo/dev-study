# 서브클래싱과 서브타이핑

## 타입

- 개념 관점의 타입 : 공통의 특징을 공유하는 대상들을 분류
- 프로그래밍 언어 관점의 타입
    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스 집합
    - 자바의 ‘+’ 연산자
- 객체지향 패러다임 관점의 타입
    - 객체의 타입을 결정하는 것은 내부 속성이 아닌 **객체가 외부에 제공하는 행동**
    - 즉, 동일한 퍼블릭 인터페이스를 공유한다면 이들은 동일한 타입으로 분류

## 타입 계층

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3d0c3019-fbc8-4caa-b9d4-a257d7bea379/ea4610e9-b8e8-40f7-baa6-63d0c8ecbace/Untitled.png)

- 슈퍼타입 : 두 타입 간의 관계에서 더 일반적인 타입 (프로그래밍언어는 객체지향, 절차적 언어의 슈퍼타입)
- 서브타입 : 두 타입 간의 관계에서 더 특수한 타입

### 객체지향 프로그래밍과 타입 계층

- 슈퍼타입 : 서브타입이 정의한 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
- 서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

👉 즉, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다는 것. 그 이유는 서브타입 인스턴스 집합은 슈퍼타입의 인스턴스 집합의 부분집합이기 때문임

## 서브클래싱과 서브타이핑

> 객체지향 언어에서 **타입**을 구현하는 일반적인 방법은 **클래스**를 이용하는 것이고, **타입 계층**을 구현하는 일반적인 방법은 **상속**을 이용하는 것이다. 이때 부모클래스가 슈퍼타입의 역할을, 자식클래스가 서브타입의 역할을 수행하도록 관계를 정의한다.
> 

### 타입계층을 구현할 때 지켜야 하는 제약사항

### **상속은 언제 사용해야 할까?**

1. 상속 관계가 is-a 관계를 모델링하는지 체크
    - ‘자식클래스는 부모클래스다’라고 말해도 괜찮은가?
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한지 체크 
    - 클라이언트 입장에서는 부모, 자식 클래스의 차이점을 몰라야 함. 이를 두 클래스 사이의 행동 호환성이라 부름

👉 설계 관점에서는 두 번째 질문에 더 초점을 맞추는 것이 중요!

### **is-a 관계 판단하기**

- is-a 관계를 만족한다는 것은 어휘적인 정의를 말하는 것이 아니다
- 기대되는 행동에 따라 타입 계층을 구성해야 한다

[예시] 

- 펭귄은 새다
- 새는 날 수 있다

```java
public class Bird {
    public void fly()
}

public class Penguin extends Bird {
    // 펭귄은 날 수 없는데...
}
```

👉 직관적인 판단으로는 ‘펭귄 = 새’가 성립될 수 있으나 새의 정의에 날 수 있다는 행동이 포함되어 있음 (어휘적인 관점에서만 펭귄 = 새 성립)

👉 만약 새의 정의에 날 수 있는 행동이 포함되지 않으면 어휘적인 관점과 행동 관점이 일치하게 됨. 이는 펭귄이 새의 서브타입이 될 수 있음을 의미함

👉 즉, 타입계층은 행동이라는 문맥에 따라 달라지기 때문에 is-a보다 행동 호환성을 따져서 타입 계층을 구성하는 것이 더 중요함

### **행동 호환성**

- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점임
- 클라이언트 입장에서 두 타입이 동일하게 행동할 것이라 기대한다면 두 타입을 ‘타입 계층’으로 묶을 수 있음
- 행동 호환성을 고려하지 않고 타입 계층을 구성했을 때, 아래와 같은 문제가 발생함

```java
// 클라이언트는 오직 날 수 있는 새만을 원한다
public void flyBird(Bird bird) {
    // 인자로 전달된 모든 bird는 날 수 있어야 함
    bird.fly();
}

// 내부 구현을 비워두는 방식은 모든 새가 날 수 있다는 클라이언트 기대를 만족하지 못함
public class Penguin extends Bird {
    @Override
    public void fly() {}
}

// 예외를 던지는 것도 클라이언트의 기대를 충족하지 못한다
public class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException();
    }
}

// 펭귄 이외의 다른 새가 상속 계층에 추가되면 타입 체크 코드를 추가해야 함
pubilc void flyBird(Bird bird) {
    // 인자로 전달된 모든 bird가 Penguin 인스턴시가 아닐 경우에만
    // fly() 메세지 전송
    if (!(bird instanceof Penguin)) {
        bird.fly();
    }
}
```

### 클라이언트의 기대에 따라 계층 분리하기

- 날 수 있는 새와 날 수 없는 새를 구분할 수 있게 상속 계층 분리하기
- fly 메세지는 날 수 있는 새인 FlyingBird만 수신 가능하게 하기

```java
// 날지 못하는 새만 협력
public class Bird {

}

// 날 수 있는 새만 협력
public class FlyingBird extends Bird {
    public void fly() {

    }
}

// 날지 못하는 펭귄
public class Penguin extends Bird {

}
```

- 또는 fly 오퍼레이션을 인터페이스로 분리하기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3d0c3019-fbc8-4caa-b9d4-a257d7bea379/8828f010-75a2-4a6a-9784-49fb4a6135ea/Untitled.png)

- Bird의 코드를 Penguin이 재사용한다면 상속보다는 합성 사용이 유리 (Penguin의 퍼블릭 인터페이스에 fly 오퍼레이션이 추가되기 때문)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/3d0c3019-fbc8-4caa-b9d4-a257d7bea379/d203f75c-d606-4bf1-9451-59b361b30bb2/Untitled.png)

- 만약 Client1의 기대가 바뀌어서 Flyer인터페이스가 변경되어야 한다면, 변경의 영향은 의존하고 있는 Bird에서 끝남 (Client2는 Flyer나 Bird에 대해 전혀 알지 못하기 때문에 영향 받지 않음(
- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의한 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(ISP)라고 함

### 서브클래싱과 서브타이핑

👉 상속을 사용하는 목적에 따라 구분됨

- **서브클래싱**
    - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 부모-자식간의 행동이 호환되지 않기 때문에 자식 인스턴스가 부모 인스턴스를 대체할 수 없음
    - 구현 상속(implementation) 또는 클래스 상속이라 부름
- **서브타이핑**
    - 타입계층을 구성하기 위해 상속을 사용하는 경우
    - 부모-자식간의 행동이 호환돼서 자식 인스턴스가 부모 인스턴스를 대체할 수 있음
    - 인터페이스 상속이라 부름
