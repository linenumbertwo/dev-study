# 다형성 (Polymorphism)

> 상속의 일차적인 목적은 코드 재사용성이 아닌 서브타입의 구현!

- 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
- 즉, 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

<img width="813" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/4dcedf3d-aace-4a71-a2db-4914d5ec5109">

- 오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우. 아래와 같이 작성해서 여러 메서드 명을 지을 필요 없이 하나의 메서드만 기억할 수 있음

```java
public class Money {
    public Money plus(Money amount) []
    public Money plus(BigDecimal amount) []
    public Money plus(long amount) []
}
```

- 강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
  -  ex) 이항 연산자 '+'에서 피연산자가 모두 정수면 정수 덧셈이고 문자열이면 연결 연산자로 동작
-  매개변수 다형성: 제네릭 프로그래밍이라 보면 됨 ex) List<T>
- 포함 다형성(서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라짐. 흔히 말하는 다형성이 이거임
  - 아래 예시와 같이 discountPolicy는 동일한 메시지를 전송하지만 객체의 타입에 따라 다르게 행동함

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening) {
      return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

## 상속의 양면성

- 객체지향은 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이기에 프로그램을 작성하기 위해선 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야함
- 상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다. (데이터 관점의 상속)
- 또한, 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함시킬 수 있다 (행동 관점의 상속)
- 이렇게 보면 상속은 재사용 메커니즘으로 보이지만, 상속은 코드 재사용의 목적 보단 **프로그램을 구성하는 개념들을 기반으로 다형성을 기능하게 하는 타입 계층을 구축**하기 위함임
    - 업캐스팅
    - 동적 메서드 탐색
    - 동적 바인딩
    - self 참조
    - super 참조

<img width="784" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/af7fd009-f6ae-4dce-97b3-cfdf930d31ac">
<img width="899" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/85157670-5c49-4832-9574-25d0d0c3d081">

- 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것이라 볼 수 있음. 즉, 자식 클래스의 인스턴스는 자동으로 부모 클래스에서 정의한 모든 인스턴스 변수를 내부에 포함하게 됨
- 행동 관점의 상속은 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것
- 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다.
- 자식 클래스의 인스턴스에서 수행할 수 있는 이유는 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 부모 클래스 안에서 탐색하기 때문임
- 객체의 경우 서로 다른 상태를 저장하기 위해 인스턴스별로 독립적인 메모리를 할당받지만 메서드의 경운 공유 가능하기에 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게된다

<img width="862" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/318b6ea8-a232-4fae-aaa3-317bdffc98d2">
<img width="831" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/8b7b5666-0d95-42f1-9675-051bf1080c21">

- 메시지를 수신한 객체는 class 포인터로 연결된 자신의 클래스에서 적절한 메서드가 존재하는지 찾고, 없으면 클래스의 parent 포인터를 따라 부모 클래스를 훑어 적절한 메서드가 존재하는지 검색한다.
- 업캐스팅: 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것 ex) Lecture lecture = new GradeLecture(...)

<img width="505" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/6573aa88-dcce-4d2c-a446-cc5e7e6eff74">
  
- 동적 바인딩: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드를 결정. 메시지를 처리할 적절한 메서드를 컴파일 시점이 아닌 실행 시점에 결정하기에 가능

## 동적 메서드 탐색과 다형성

- 객체지향 시스템은 다음 규칙에 따라 실행할 메서드를 선택함
  - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사함. 존재하면 메서드를 실행하고 탐색을 종료함
  - 메서드를 찾지 못했으면 부모 클래스에서 메서드 탐색을 계속함. 적합한 메서드를 찾을 때까지 상속 계층을 타고 올라감
  - 최상위 클래스까지 이르렀는데 메서드를 발견하지 못한 경운 예외를 발생시키며 탐색을 중단함
- 메시지 탐색시 중요한 변수로 **self 참조**가 있다. 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정함
- 동적 메서드 탐색은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지며 탐색이 종료되면 self 참조는 자동으로 삭제됨. 이때 class 포인터와 parent 포인터도 조합해서 활용함

<img width="843" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/455beb20-7a71-418c-9ff0-07eca466fab5">

- lecture.average("A")의 경우 GradeLecture에 있기에 여기서 메서드 탐색이 종료됨

<img width="756" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/6905ce5f-0b79-4cce-8de6-a300c4657658">

- lecutre.average()의 경우엔 Lecture에 있어서 parent 까지 탐색하여 실행함

<img width="725" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/74cf55b6-57c7-4e3f-8cdf-d9a56b8769e7">

> 메서드 호출은 현재 클래스의 메서드를 호출하는게 아니라 **현재 객체**에게 메시지를 전송하는 것이다. 그건 바로 self 참조가 가리키는 객체

### 이해할 수 없는 메시지

- 정적 타입에선 상속 계층을 따라가며 메시지를 처리할 수 있는 메서드가 존재한지 검색하고 최종적으로 Object 클래스까지 올라와서 못 찾으면 컴파일 에러를 발생시킨다.
- 동적 타입인 경우에도 수신한 객체부터 클래스 방향으로 메서드를 탐색하지만 컴파일 단계가 존재하지 않기에 실제로 실행 전까진 처리 가능 여부를 알 수 없음
- 동적 타입 언어에선 이해할 수 없는 메시지에 대해 예외를 처리할 수 있는 메서드를 구현할 수 있지만 디버깅 과정을 더 어렵게 만들 수 있다.
- 정적 타입은 유연성은 부족하지만 모든 메시지는 컴파일 타임에서 확인되고 컴파일 에러가 나오기에 안정적으로 처리할 수 있다.

### super

- super 참조를 통해 부모 클래스에게 **메시지를 전송**할 수 있다. (호출이 아님)
- super 참조를 통해 상속 계층의 올라가며 메시지를 찾아 호출할 수 있게 된다.
- self 전송에서 메시지 탐색을 시작하는 클래스는 미정이지만 super 전송에는 미리 부모 클래스가 정해짐 (컴파일 시점에 미리 결정해 놓을 수 있음)
![image](https://github.com/somefood/cs-study/assets/24751937/12ae1835-3e7e-4699-8fe1-00827574797a)
