# 다형성 (Polymorphism)

> 상속의 일차적인 목적은 코드 재사용성이 아닌 서브타입의 구현!

- 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
- 즉, 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

<img width="813" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/4dcedf3d-aace-4a71-a2db-4914d5ec5109">

- 오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우. 아래와 같이 작성해서 여러 메서드 명을 지을 필요 없이 하나의 메서드만 기억할 수 있음

```java
public class Money {
    public Money plus(Money amount) []
    public Money plus(BigDecimal amount) []
    public Money plus(long amount) []
}
```

- 강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
  -  ex) 이항 연산자 '+'에서 피연산자가 모두 정수면 정수 덧셈이고 문자열이면 연결 연산자로 동작
-  매개변수 다형성: 제네릭 프로그래밍이라 보면 됨 ex) List<T>
- 포함 다형성(서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라짐. 흔히 말하는 다형성이 이거임
  - 아래 예시와 같이 discountPolicy는 동일한 메시지를 전송하지만 객체의 타입에 따라 다르게 행동함

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening) {
      return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```
