# 다형성 (Polymorphism)

> 상속의 일차적인 목적은 코드 재사용성이 아닌 서브타입의 구현!

- 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력
- 즉, 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

<img width="813" alt="image" src="https://github.com/somefood/cs-study/assets/24751937/4dcedf3d-aace-4a71-a2db-4914d5ec5109">

- 오버로딩 다형성: 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우. 아래와 같이 작성해서 여러 메서드 명을 지을 필요 없이 하나의 메서드만 기억할 수 있음

```java
public class Money {
    public Money plus(Money amount) []
    public Money plus(BigDecimal amount) []
    public Money plus(long amount) []
}
```

- 강제 다형성: 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
  -  ex) 이항 연산자 '+'에서 피연산자가 모두 정수면 정수 덧셈이고 문자열이면 연결 연산자로 동작
-  매개변수 다형성: 제네릭 프로그래밍이라 보면 됨 ex) List<T>
- 포함 다형성(서브타입 다형성): 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제 수행되는 행동이 달라짐. 흔히 말하는 다형성이 이거임
  - 아래 예시와 같이 discountPolicy는 동일한 메시지를 전송하지만 객체의 타입에 따라 다르게 행동함

```java
public class Movie {
    private DiscountPolicy discountPolicy;

    public Money calculateMovieFee(Screening screening) {
      return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

## 상속의 양면성

- 객체지향은 데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것이기에 프로그램을 작성하기 위해선 항상 데이터와 행동이라는 두 가지 관점을 함께 고려해야함
- 상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다. (데이터 관점의 상속)
- 또한, 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함시킬 수 있다 (행동 관점의 상속)
- 이렇게 보면 상속은 재사용 메커니즘으로 보이지만, 상속은 코드 재사용의 목적 보단 **프로그램을 구성하는 개념들을 기반으로 다형성을 기능하게 하는 타입 계층을 구축**하기 위함임
    - 업캐스팅
    - 동적 메서드 탐색
    - 동적 바인딩
    - self 참조
    - super 참조
