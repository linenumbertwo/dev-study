
## 도입

다형성이 구현되는 메커니즘의 이해 : 런타임에 메세지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정의 이해.

## 다형성

다형성의 종류는 유니버설(매개변수, 포함), 임시(오버로딩, 강제 다형성으로 분류할 수 있다.

매개변수 다형성 - 제네릭 프로그래밍과 관련  : List의 경우 생성 시점에 생성되는 타입이 정해진다.
포함 다형성 - 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 것, 객체지향 프로그래밍에서 주로 사용되는 개념

## 상속의 양면성

- 상속의 주 목적은 코드 재상요이 아니다. 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것.

상속 메커니즘 이해의 필요한 개념 - 업캐스팅, 동적 메서드 탐색, 동적 바인딩, Self 참조, Super 참조


### 데이터, 행동 관점의 상속

데이터 관점의 상속
- 메모리 상에 생성된 객체는 자식 객체 -> 부모 객체 순서로 접근 가능한 링크가 존재한다.
- 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 개념
행동 관점의 상속
- 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것
- 부모클래스의 퍼블릭 인터페이스가 자식 클래스에서 사용가능 한 이유?
- 상속 관계로 연결된 클래스 사이의 메서드 탐색 과정의 이해 : 객체와 클래스 사이의 관계
- 객체의 경우에는 인스턴스별로 독립적인 메모리를 할당받아야 하지만, 메서드의 경우에는 공유가 가능하다.
- 클래스는 한 번 메모리에 로드하고, 각 인스턴스가 클래스에 대한 포인터를 갖게 하는게 경제적

## 업캐스팅과 동적 바인딩

### 같은 메세지, 다른 메서드

업캐스팅 : 부모 클래스 타입으로 선언된 변수에서 자식 클래스의 인스턴스를 할당할 수 있다.
동적 바인딩 : 선언된 변수의 타입(책의 예제에서는 Lecture)이 아니라 메세지를 수힌하는 객체의 타입(GradeLecture)에 따라 실행되는 메서드가 결정된다.
다운 캐스팅 : 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환

## 동적 메서드 탐색과 다형성

메서드의 탐색은 자동적인 메세지 위임, 동적인 문맥을 사용한다.
메서드의 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다. 이 때, 자식 클래스가 이해하지 못하는 메서드의 경우 부모 클래스로 위임한다. 즉 자동적인 메세지 위임이 이루어진다. 또한, 메세지를 수신했을 때, 어떤 메서드를 실행할 것인지는 `self 참조`를 활용한 동적인 문맥으로 결정된다.
#### self 참조

객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다. 동적 메서드의 탐색은 self가 가리키는 클래스에서 시작해서 상속 계층의 역방향으로 이뤄진다. 메서드 탐색 종료 후, self 참조는 소멸. Java 에서는 self 참조를 this라고 부른다.

#### self 전송

- self 참조가 가리키는 자기 자신에게 메세지를 전송하는 것. 
- self 참조가 가리키는 그 객체에서 시작해서 메서드 탐색이 다시 이루어진다.
- 현재 클래스의 메서드를 호출하는 것이 아니라 현재 객체에게 메세지를 전송하는 것


### Self vs Super

동적인 Self, 정적인 Super


## 상속과 위임

자식(GradeLecture), 부모(Lecture)가 동일한 self 참조를 갖는 경우

```Ruby
class Lecture
  def initialize(name, scores)
    @name = name
    @scores = scores
  end

  def stats(this)
    "Name: #{@name}, Evaluation Method: #{this.evaluationMethod(this)}"
  end

  def getEvaluationMethod()
    "Pass or Fail"
  end
end
```

```Ruby
class GradeLecture
  def initialize(name, canceled, scores)
    @parent = Lecture.new(name, scores)
    @canceled = canceled
  end

  def stats(this)
    @parent.stats(this) < 위임 : 부모 객체에게 자신이 수신한 메세지의 처리를 요청
  end

  def getEvaluationMethod()
    "Grade"
  end
end

```

포워딩과 위임

객체가 다른 객체에게 요청을 처리할 때 Self 참조를 전달하냐 혹은 하지 않느냐에 따라 포워딩과 위임으로 나뉜다. 포워딩의 경우 코드를 재사용하는 경우에 해당한다. 위임의 경우 클래스를 이용한 상속 관계를 객체 사이의 합성 관계로 대체해서 다형성을 구현하는 것
