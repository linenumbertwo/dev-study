# Object 11장

# 합성과 유연한 설계

**상속**

- 부모-자식 의존성 : 컴파일 타임, is-a 관계
- 부모 클래스 ‘구현’에 의존
- 클래스 사이의 정적인 관계 (코드 작성 시점에 결정되어 변경 불가능)

**합성**

- 객체-객체 의존성 : 런타임, has-a관계
- 객체의 퍼블릭 인터페이스에 의존 (객체 내부 변경의 영향 최소화)
- 객체 사이의 동적인 관계 (실행 시점에 동적으로 변경)

👉  즉, 변경에 더 안정적인 코드는 합성이다

## 상속을 합성으로 변경하기

상속 관계를 합성으로 변경하면..

### 1. 불필요한 인터페이스 상속 문제 해결

(클래스 내부에 객체 생성)

- 상속에서는 기존 부모 클래스가 가지고 있던 오퍼레이션이 모두 상속됨
- 합성으로 변경 시 불필요한 오퍼레이션을 배제시킬 수 있음
- 객체 오퍼레이션을 포함한  퍼블릭 인터페이스(ex. get, set)를 정의하여 사용

### 2. 메서드 오버라이딩 오작용 문제

- 인터페이스 구현체(HashSet)를 상속받는 것이 아닌 해당 인터페이스(Set)를 직접 구현
- 포워딩 : 클래스 인스턴수 변수로 저장하여 가져다 쓰는 방식
- 포워딩 메서드 : 필드의 인스턴스를 참조해 사용하는 메서드

### 3. 부모 클래스와 자식 클래스의 동시 수정 문제

- 합성을 사용해도 함께 수정되는 근본적인 문제는 해결되지 않음
- 그러나 파급효과를 최대한 객체 내부로 캡슐화할 수 있음

## 상속으로 인한 조합의 폭발적인 증가

상속 남용의 문제

- 하나의 기능을 추가or수정을 위해 많은 수의 클래스를 추가하거나 수정해야 함
- 단일 상속만 지원하는 언어는 상속으로 인해 중복 코드의 양이 늘어남

### 1. 추상 메서드 사용

- 자식 클래스가 부모 클래스의 메서드를 재사용하기 위해 super 호출을 사용하게 되면 부모-자식간의 결합도가 높아짐
- 부모 클래스의 메서드를 호출하지 않도록 **추상메서드** 사용 (결합도를 느슨하게 만들 수 있음)
- 그러나  모든 자식들이 해당 추상메서드를 오버라이딩 해야하는 문제점이 발생
- 훅 메서드로 작성하면 이를 보완할 수 있음
    - 부모클래스에 추상 메서드를 추가혹 다른 메서드 안에서 호출하는 것
    - 기본 구현을 제공하는 메서드

### 2. 합성 관계로 변경

- 상속 : 조합의 결과를 개별 클래스 안으로 넣는 방식
- 합성 : 조합을 구성하는 요소들을 개별 클래스로 구현 후 → 실행 시점에 인스턴스로 넣는 방식
- 상위 객체를 인터페이스로 정의 → 클래스에 참조자로 지정하여 생성자를 통해 런타임에 주입되게끔 설계

## 믹스인

- 코드 일부를 클래스 안에 섞어 재사용하는 방법
- 컴파일 시점에 필요한 코드를 조합
    - 특정 A클래스를 상속하여 구현할 경우 A클래스의 자손에 해당하는 경우만 믹스인 될 수 있다는 제약을 걸 수 있음  (문맥 제공 레벨)
    - 상속해서 구현했을 때 super의 경우 믹스인 되는 시점에서 결정되기 때문에 큰 문제가 되지 않음
