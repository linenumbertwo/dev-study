# 11장

합성 = 전체를 표현하는 객체가 부분을 표현하는 객체를 포함

합성관계 = has-a관계라고 부름 —> 객체의 멤버 필드라고 불리는 객체를 뜻함.

상속 → 부모 클래스와 다른 부분만 추가 혹은 재정의 하며 기존 코드 쉽게 확장 가능

그러나, 상속 활용 위해서는 부모 클래스를 알아야 하고 그러면 결합도가 높아짐. 

합성은 구현에 의존하지 않음.

합성 관계는 동적인 관계로서 실행 시점에 동적으로 변경 가능하다는 특징을 가지고 있다.

—> 런타임 의존성 관계 → 런타임 의존성이란 애플리케이션을 실행하는 시점에 결정되는 의존성이며, **객체 사이의 의존성**에 해당한다. **일반적으로 추상화된 클래스나 인터페이스에 의존** 할 때 런타임 의존성을 갖게 된다.

즉, 필자는 합성이 번거롭겠지만 상속보다 좋다.

1. 상속을 합성으로 변경하기
- 상속 남용 시 문제점 3가지
    - 불필요한 인터페이스 상속 문제
        - 자식 클래스에 부적합한 오퍼레이션 상속
    - 메서드 오버라이딩의 오작용 문제
        - 메서드 호출시 부모 클래스의 메서드 호출 방법에 영향을 받음
    - 부모 클래스와 자식 클래스의 동시 수정 문제
        - 부모 클래스 변경시 자식 클래스도 변경 필요

→ 상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고 부모 클래스의 인스턴스를 자식 클래스의 인스턴스 변수로 선언하면 된다.

1. 불필요한 인터페이스 상속 문제
<img width="637" alt="스크린샷 2023-11-10 오전 9 30 36" src="https://github.com/somefood/cs-study/assets/104557007/c1ba5ade-c9ef-499e-b1d5-7edcf614ac18">

두 클래스 간의 상속을 끊어내고, HashTable을 Properties의 인스턴스 변수로 포함시켜 합성관계로 변환

→ 불필요한 오퍼레이션들이 Properties 클래스 오염시키지 않음.

→ 클라이언트는 오직 Properties에서 정의한 오퍼레이션만 사용할 수 있음.

1. 메서드 오버라이딩의 오작용 문제
    <img width="336" alt="스크린샷 2023-11-10 오전 9 31 04" src="https://github.com/somefood/cs-study/assets/104557007/3a2713a5-d726-4d73-b9d4-f8070105f0f2">

    
- Set의 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것을 볼 수 있는데 그것이 포워딩.
- 동일한 메서드를 호출하기 위해 추가된 메서드를 포워딩 메서드라고 부른다.
- 포워딩 = 기존 클래스의 인터페이스를 그대로 외부에 제공하며 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법

1. 부모 클래스와 자식 클래스의 동시 수정 문제
    <img width="341" alt="스크린샷 2023-11-10 오전 9 31 25" src="https://github.com/somefood/cs-study/assets/104557007/06b2c9d7-8424-4809-bd94-15eb11b8f0be">
    
- 이 경우는 Playlist와 PersonalPlaylist를 함께 수정해야 하는 문제 해결 안됨.
- 그렇다 하더라도 playlist의 내부 구현을 변경하더라도 파급효과를 최대한 personalplaylist 내부로 캡슐화 할 수 있기 때문.

쨋든 상속보다 합성이 좋다.

1. 상속으로 인한 조합의 폭발적인 증가
- 작은 기능들을 조합해 더 큰 기능을 수행하는 객체를 만들 때 문제점 발생
    1. 하나의 기능 추가 혹은 수정하기 위해 불필요한 작업양
    2. 단일 상속만 지원하는 언어의 경우 상속으로 오히려 중복 코드 양 증가 가능성
    
    → 이러한 문제는 합성 사용으로 간단하게 해결할 수 있다.
    

1. 상속 이용시
    1. 기본 정책에 세금 정책 조합시
        1. 
            <img width="303" alt="스크린샷 2023-11-10 오전 9 31 41" src="https://github.com/somefood/cs-study/assets/104557007/62afc2c1-6856-41b7-890c-32703dece15c">
            
            눈 여겨 볼 점은 super 호출을 사용하면 원하는 결과를 쉽게 얻을 수 있지만 ‘결합도’가 높아진다는 것.
            
            부모 클래스의 메서드를 호출하지 않고 부모 클래스에 추상 메서드를 제공하는 것이 오히려 더 좋은 방법.
            
        
         1. 그러나 이 방식도 부모 클래스에 추상 메서드를 추가하면 모든 자식 클래스들이 추상 메서드로 오버라 이딩해야 하는 문제가 발생. → 번거로움.
        
        1. 중복코드
        2. 상속의 남용시 클래스 폭발 또는 조합의 폭발 문제 발생 가능. → 중복 코드가 기하급수적으로 늘어나는 것.

이러한 문제들을 해결하기 위해서는 

합성을 사용해야 한다.

1. **상속은 개별 클래스 안으로 밀어 넣는 방법이지만 반대로, 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후 실행  시점에 인스턴스를 조립하는 방법 —> 코드를 이해하기에는 어려워짐**
2. 그러나, 설계는 변경과 유지보수를 위해 존재한다는 사실을 기억

<img width="304" alt="스크린샷 2023-11-10 오전 9 32 19" src="https://github.com/somefood/cs-study/assets/104557007/5ed9d640-1569-4156-bd63-209f9a0cfe79">



기본 정책의 경우는 고민할 필요 없이 정해져있는 것이기 때문에 상속을 사용하면 되지만 부가 정책의 경우 다양한 경우의 수가 있기에 합성의 힘이 더 커진다.

- 처음에는 어려울 수 있으나, 정해진 규칙에 따라 객체를 생성하고 조합하는 합성을 하는 설꼐 자체에 익숙해지면 예측 가능하고 일관성 있는 것을 알 수 있다.

즉, 결과적으로 객체 합성이 클래스 상속보다 더 좋은 방법.

- 상속 자체는 구현에 자식 클래스를 강하게 결합시키기에 코드의 진화를 방해.

### 믹스인

- 합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법이다.
- 상속과는 다른 방식.
- 상속의 결과로 부모 클래스의 코드를 재사용한다는 사실은 맞다. 그러나 **상속의 목적**은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것.
- 반대로 믹스인은 코드를 다른 코드 안에 섞어 넣기 위한 방법.
- 쉽게 말하면 상속 = 클래스와 클래스 사이의 관계를 고정시킴
- 반대로 믹스인은 = 유연하게 관계를 재구성 할 수 있다. → 결합도 문제 해결

```scala
trait RateDiscountablePolicy extends BasicRatePolicy {
  val discountAmount: Money
  
  override def calculateFee(phone: Phone): Money = {
    val fee = super.calculateFee(phone)
    fee - discountAmount
  }
}
```

스칼라 언어에서 제공하는 믹스인 기법

- trait는 super 라는 코드가 부모 클래스 하나를 고정하지 않음.
- 위 예제에서 super는 BasicRatePolicy의 클래스 어떤 것이든 될 수 있다.
- BasicRatePolicy 클래스이든, BasicRatePolicy를 상속한 자식 클래스이든 trait에 대한 코드를 믹스인 할 수 있다.

믹스인 사용시 상속의 문제였던 클래스 폭발 여전히 존재?

→ 믹스인은 존재하지 않음. 믹스인을 사용하면 특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있기 때문. 믹스인의 이러한 특징을 **쌓을 수 있는 변경**

이라고 부른다.
