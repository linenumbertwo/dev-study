# 응집도: 흩어져 있는 것들

- 응집도는 `모듈 내부에 있는 데이터와 로직 사이의 관계가 얼마나 강한지 나타내는 지표`이다.
- 모듈은 클래스, 패키지, 레이어 등을 모두 포함할 수 있다. (책에서는 보통 클래스로 보면 됨)
- 응집도가 높은 구조는 변경하기 쉬우며, 바람직한 구조고 반대의 경우엔 구조 변경 시 문제가 발생하기 쉬움
- 응집도 낮은 구조는 대표적으로 데이터 클래스이며, 아래의 예제들도 응집도를 낮추는 악마들임

## 5.1 static 메서드 오용

- 아래에 OrderManager는 int 형 데이터 두 개를 합치는 형태이다.
- 근데 int 값은 moneyData란 곳에 있는데, OrderManager에게 위임하면서 응집도가 떨어져 있음
- 객체 지향 설계의 기본은 `클래스가 스스로를 보호할 수 있게, 데이터와 로직을 모아 응집도가 높은 구조로 설계해야함`
- static 메서드는 응집도의 영향을 받지 않는 경우 사용하라
  - 로그 출력 전용 메서드
  - 포맷 변환 전용 메서드
  - 팩토리 메서드

```java
class OrderManager {
    static int add(int moneyAmount1, int moneyAmount2) {
        return moneyAmount1 + moneyAmount2;
    }
}

moneyData1.amount = OrderManager.add(moneyData1.amount, moneyData2.amount);
```

## 5.2 초기화 로직 분산

- 다음은 기프트 포인트 관련 클래스이다.

```java
public class GiftPoint {
    private static final int MIN_POINT = 0;
    final int value;

    public GiftPoint(final int point) {
        if (point < MIN_POINT) {
            throw new IllegalArgumentException("포인트를 0 이상 입력해야 합니다.");
        }
        this.value = point;
    }
    
    GiftPoint add(final GiftPoint other) {
        return new GiftPoint(value + other.value);
    }
    
    boolean isEnough(final ConsumptionPoint point) {
        return point.value <= value;
    }
    
    GiftPoint consume(final ConsumptionPoint point) {
        if (!isEnough(point)) {
            throw new IllegalArgumentException("포인트가 부족합니다.");
        }
        return new GiftPoint(value - point.value);
    }
}

GiftPoint standardMembershipPoint = new GiftPoint(3000);
GiftPoint premiumMembershipPoint = new GiftPoint(10000);
```

- 얼핏 보면 회원별로 잘 준거 같지만, 생성자를 public으로 만듦으로써 의도하지 않은 용도로 사용될 수 있음. 이는 곧, 유지 보수 어려움으로 이어짐
- 아래 코드와 같이 생성자를 private으로 만들고, 팩토리 메서드를 활용할 수 있음
- 다음과 같이 하여 무분별한 남용을 막으며, 관련된 사양으로만 만들 수 있게 해준다.
- 생성 로직이 너무 많아지는 경우 클래스가 무슨 일을 하는지 알기 어려워지기에 너무 많아진다면, 생성 전용 팩토리 클래스를 분리하는 것도 좋음

```java
public class GiftPoint {
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;
    final int value;

    private GiftPoint(final int point) {
        if (point < MIN_POINT) {
            throw new IllegalArgumentException("포인트를 0 이상 입력해야 합니다.");
        }
        this.value = point;
    }
    
    static GiftPoint forStandardMembership() {
        return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
    }
    
    static GiftPoint forPremiumMembership() {
        return new GiftPoint(PREMIUM_MEMBERSHIP_POINT);
    }
}

GiftPoint standardMembershipPoint = GiftPoint.forStandardMembership();
GiftPoint premiumMembershipPoint = GiftPoint.forPremiumMembership();
```

## 5.3 범용 처리 클래스 (Common/Util)

- static 메서드를 빈번하게 볼 수 있는 클래스로, 범용 처리를 위한 클래스로 사용
- 하지만 이 또한 응집도가 낮은 구조를 만들 수 있게 됨
- 아래와 같이 처음엔 세금 포함 금액만 계산하는 static 메서드를 작성했다

```java
class Common {
    static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax, BigDecimal taxRate) {
        return amountExcludingTax.multiply(taxRate);
    }
}
```

- 그러다 점차 여러 클래스가 모이게 되면, 이 클래스의 역할이 불분명해진다.
- 꼭 필요한 경우가 아니면, 범용 처리 클래스는 만들지 않고, 객체 지향 설계를 토래도 만들도록 하자

```java
class Common {
    static BigDecimal calcAmountIncludingTax(BigDecimal amountExcludingTax, BigDecimal taxRate) {
        return amountExcludingTax.multiply(taxRate);
    }

    static boolean hasResigned(User user) {}

    static void createOrder(Product product) {}

    static boolean isValidPhoneNumber(String phoneNumber) {}
}
```