# 3장 구글 맵

## 1단계: 문제 이해 및 설계 범위 확정

### 기능 요구 사항

- 사용자 위치 갱신
- 경로 안내 서비스(ETA 서비스 포함)
- 자도 표시

### 비기능 요구사항 및 제약사항

- 정확도: 사용자에게 잘못된 경로를 안내하면 안 됨
- 부드러운 경로 표시: 클라이언트를 통해 제공되는 경로 안내 용도의 지도는 화면에 아주 부드럽게 표시되고 갱신되어야 함
- 데이터 및 배터리 사용량: 클라이언트는 가능한 한 최소한의 데이터와 배터리를 사용해야 한다. (모바일에서 아주 중요함)
- 일반적으로 널리 통용되는 가용성 및 규모 확장성 요구사항을 만족해야 함

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 위치 서비스

사용자의 위치를 기록하는 역할 담당

- 클라이언트는 t초 마다 자기 위치를 전송
- 주기적으로 전송하여 얻는 이점
  - 데이터 스트림을 활용하여 시스템 점진적 개선
  - 실시간 교통 상황 모니터링
  - 새로운 도로 및 폐쇄 도로 탐지 가능
  - 사용자 행동 양태를 분석하여 개인화된 경험 제공
  - ETA를 좀 더 정확하게 산출할 수 있음
  - 교통 상황에 따라 다른 경로를 안내할 수 있음
- 하지만 너무 많이 보내면 서버에 부하가 오기에, 버퍼링을 해두어 일괄 요청(batch request)하여 전송 빈도를 낮춤
- 이를 쓰기 요청 빈도에 최적화되고 규모 확장이 용이한 카산트라(Cassandra) 같은 데이터베이스 활용

### 경로 안내 서비스

- A에서 B지점으로 가는 합리적으로 빠른 경로를 찾아 주는 역할 담당
- 결과를 얻는 데 드는 시간 지연은 어느 정도 감내할 수 있음
- 계산된 경로는 최단 시간 경로일 필요 없으나 정확도는 보장되어야 함

### 지도 표시

- 확대 수준별로 한 벌씩 지도 타일을 저장하려면 수백 PB가 필요함.
- 이 모두를 클라이언트가 가지고 있는 것은 실용적이지 않음
- 클라이언트의 위치 및 현재 클라이언트가 보는 확대 수준에 따라 필요한 타일을 서버에서 가져오는 접근법이 바람직함
- 지오해싱을 활영하여 URL을 갖고오고 이를 CDN의 주소와 매핑하여 가져오는것이 좋음

## 3단계: 상세 설계

### 데이터 모델

다음과 같은 데이터를 취급

1. 경로 안내 타일
2. 사용자 위치
3. 지오코딩 데이터
4. 미리 계산해 둔 지도 타일 데이터

#### 경로 안내 타일

- 외부의 도로 데이터를 받아와 이를 계속 수집해서 개선해야 함
- 해당 데이터는 방대한 양의 도로 및 메타데이터(이름, 관할구, 위도, 경도 등의 도로 부속 정보)로 구성
- 그래프 자료 구조 형태로 가공되지 않은 데이터이므로, 경로 안내 타일 처리 서비스(routing tile processing service)라 불리는 오프라인 데이터 가공 파이프라인을 주기적으로 실행하고 변환함
- 가공된 그래프 데이터는 메모리에 인접 리스트(adjacency list) 형태로 보관하지만, 여기서는 너무 크기가 방대함
- 그래프의 노드와 선을 데이터베이스 레코드로 넣는 방법도 있지만 비용이 많이 듬 (DB의 기능도 필요하지 않음)
- S3같은 객체 저장소(object storage)에 파일을 보관하고, 그 파일을 이용할 경로 안내 서비스에서 적극적으로 캐싱하는 것이 좋음
- 인접 리스트를 이진 파일(binary file) 형태로 직렬화(serialize) 해주면 됨
- 이때 지오해시 기준으로 분류해두는 것이 좋음

#### 사용자의 위치 데이터

- 도로 데이터 및 경로 안내 타일을 갱신하는데 이용
- 실시간 교통 상황 데이터나 교통 상황 이력 데이터베이스를 구축하는 데도 활용됨
- 데이터 스트림 프로세싱 서비스는 이 위치 데이터를 처리하여 지도 데이터를 갱신함
- 이때 쓰기 연산을 잘 처리하는 카산드라를 사용하면 좋음

#### 지오코딩 데이터베이스

- 주소를 위도/경도 쌍으로 변환하는 정보를 보관
- 레디스 같이 읽기 연산이 빠른 키-값 저장소를 활용
- 지도 데이터는 변경이 비교적 드물기 때문
- 출발지와 목적지 주소는 경로 계획 서비스에 전달하기 전에 이 데이터베이스를 통해 위도/경도 쌍으로 변환되어야 함

#### 미리 만들어 둔 지도 이미지

- 단말이 특정 영역의 지도를 요청하면 인근 도로 정보를 취합하여 모든 도로 및 관련 상세 정보가 포함된 이미지를 만들어야 함
- 계산 자원이 많이 들고 중복 요청이 많을거라 캐시해서 사용하는 방법이 좋음
- 확대 수준별로 미리 만들어 두는 것이 좋음

### 경로 안내 서비스

#### 경로 계획 서비스(route planner service)

- 현재 교통 상황과 도로 상태에 입각하여 이동 시간 측면에서 최적화된 경로를 제안하는 역할 담당

#### 최단 경로 서비스(shortest path service)

- 출발지와 목적지 위도/경도를 입력 받아 k개 최단 경로를 반환해줌
- 이때 교통이나 도로 상황은 고려하지 않고, 도로 구조에만 의존해서 계산
- 도로망 그래프는 거의 정적이므로 캐시해두면 좋음
- 객체 저장소에 저장된 경로 안내 타일에 대해 A* 경로 탐색 알고리즘의 한 형태를 실행
  - 출발지 목적지의 위/경도 입력받아 지오해시로 변환한 다음 출발지와 목적지 경로 안내 타일을 얻음
  - 출발지 타일에서 시작하여 그래프 자료 구조를 탐색해 나감. 필요한 주변 타일은 객체 저장소에서 받음. 경로가 충분히 학보될 때까지범위확대해서 가져옴

#### 예상 도착 시간 서비스 (ETA, Estimated Time of Arrival)

- 경로 계획 서비스는 최단 경로 목록을 수신하면 예상 도착 시간 서비스(ETA)를 호출하여 그 경로 각각에 대한 소요 시간 추정치를 구함
- 예상 도착 시간 서비스는 기계 학습을 활용해 현재 교통 상황 및 과거 이력에 근거하여 계산함

#### 순위 결정 서비스

- ETA 예상치를 구하고 나면 순위 결정 서비스(ranker)에 관련 정보를 모두 전달하여 사용자가 정의한 필터링 조건을 적용함
- 필터링 사례: 유료 도로 제외, 고속도로 제외 등
- 순위 결정 서비스의 필터링이 끝나면 남은 경로를 소요 시간 순으로 정렬하여 결과를 반환함

#### 중요 정보 갱신 서비스들

- 카프카 위치 데이터 스트림을 구독하고 있다가 중요 데이터를 비동기적으로 업데이트하여 그 상태를 항상 최신으로 유지하는 역할 담당
- 사례: 실시간 교통 정보 데이터베이스, 경로 안내 타일
- 경로 안내 타일 처리 서비스는 도로 데이터에 새로 발견된 도로, 폐쇄되었음이 확인된 도로 정보를 반영하여 지속적으로 갱신함

#### 전송 프로토콜

경로 안내 중 경로 상황이 변경될 수 있으므로, 데이터를 모바일 클라이언트에 안정적으로 보낼 방법이 필요하다.
이때 사용할 수 있는 프로토콜론 모바일 푸시 알림(mobile push notification), 롱 폴링(long polling), 웹소켓(WebSocket), 서버 전송 이벤트(Server-Sent Events, SSE) 등이 있고,
다음과 같이 고려해 볼 수 있다.

- 모바일 푸시 알림은 메시지 크기가 매우 제한적(IOS 경우 최대 4096바이트)라 부적합 (웹 애플리케이션선 지원 X)
- 웹 소켓은 서버에 주는 부담이 크지 않아서 롱 폴링보다 좋은 방안
- SSE를 사용할 수 있지만, 양방향 통신이 필요할 수 있기에 웹 소켓이 최종 선택

> 웹소켓 SSE 비교

|              | Socket                        | Server-Sent-Event                                 |
|--------------|-------------------------------|---------------------------------------------------|
| 브라우저 지원      | 대부분 브라우저에서 지원                 | 대부분 모던 브라우저 지원(polyfills 가능)                      |
| 통신 방향        | 	양방향                          | 	일방향(서버에서 클라이언트로)                                 |
| 리얼타임         | Yes	                          | Yes                                               |
| 데이터 형태       | Binary, UTF-8	                | UTF-8                                             |
| 자동 재접속       | No                            | 	Yes(3초마다 재시도 )                                   |
| 최대 동시 접속 수   | 	브라우저 연결 한도는 없지만 서버 셋업에 따라 다름 | 	HTTP를 통해서 할 때는 브라우저당 6개 까지 가능 / HTTP2로는 100개가 기본 |
| 프로토콜	        | websocket	                    | HTTP                                              |
| 베터리 소모량      | 큼	                            | 작음                                                |
| Firewall 친화적 | Nope                          | Yes                                               |
